[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "getStdout",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "getArgs",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "getStdout",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "getArgs",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "fixPrivateResources",
        "importPath": "patch_apk.utils.fix_private_resources",
        "description": "patch_apk.utils.fix_private_resources",
        "isExtraImport": true,
        "detail": "patch_apk.utils.fix_private_resources",
        "documentation": {}
    },
    {
        "label": "fixPrivateResources",
        "importPath": "patch_apk.utils.fix_private_resources",
        "description": "patch_apk.utils.fix_private_resources",
        "isExtraImport": true,
        "detail": "patch_apk.utils.fix_private_resources",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Bar",
        "importPath": "progress.bar",
        "description": "progress.bar",
        "isExtraImport": true,
        "detail": "progress.bar",
        "documentation": {}
    },
    {
        "label": "Bar",
        "importPath": "progress.bar",
        "description": "progress.bar",
        "isExtraImport": true,
        "detail": "progress.bar",
        "documentation": {}
    },
    {
        "label": "Bar",
        "importPath": "progress.bar",
        "description": "progress.bar",
        "isExtraImport": true,
        "detail": "progress.bar",
        "documentation": {}
    },
    {
        "label": "Bar",
        "importPath": "progress.bar",
        "description": "progress.bar",
        "isExtraImport": true,
        "detail": "progress.bar",
        "documentation": {}
    },
    {
        "label": "Bar",
        "importPath": "progress.bar",
        "description": "progress.bar",
        "isExtraImport": true,
        "detail": "progress.bar",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "packaging.version",
        "description": "packaging.version",
        "isExtraImport": true,
        "detail": "packaging.version",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "packaging.version",
        "description": "packaging.version",
        "isExtraImport": true,
        "detail": "packaging.version",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "packaging.version",
        "description": "packaging.version",
        "isExtraImport": true,
        "detail": "packaging.version",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "importPath": "patch_apk.utils.raw_re_replace",
        "description": "patch_apk.utils.raw_re_replace",
        "isExtraImport": true,
        "detail": "patch_apk.utils.raw_re_replace",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "importPath": "patch_apk.utils.raw_re_replace",
        "description": "patch_apk.utils.raw_re_replace",
        "isExtraImport": true,
        "detail": "patch_apk.utils.raw_re_replace",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "importPath": "patch_apk.utils.raw_re_replace",
        "description": "patch_apk.utils.raw_re_replace",
        "isExtraImport": true,
        "detail": "patch_apk.utils.raw_re_replace",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "importPath": "patch_apk.utils.raw_re_replace",
        "description": "patch_apk.utils.raw_re_replace",
        "isExtraImport": true,
        "detail": "patch_apk.utils.raw_re_replace",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "importPath": "patch_apk.utils.raw_re_replace",
        "description": "patch_apk.utils.raw_re_replace",
        "isExtraImport": true,
        "detail": "patch_apk.utils.raw_re_replace",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "importPath": "patch_apk.utils.raw_re_replace",
        "description": "patch_apk.utils.raw_re_replace",
        "isExtraImport": true,
        "detail": "patch_apk.utils.raw_re_replace",
        "documentation": {}
    },
    {
        "label": "disableApkSplitting",
        "importPath": "patch_apk.utils.disable_apk_split",
        "description": "patch_apk.utils.disable_apk_split",
        "isExtraImport": true,
        "detail": "patch_apk.utils.disable_apk_split",
        "documentation": {}
    },
    {
        "label": "disableApkSplitting",
        "importPath": "patch_apk.utils.disable_apk_split",
        "description": "patch_apk.utils.disable_apk_split",
        "isExtraImport": true,
        "detail": "patch_apk.utils.disable_apk_split",
        "documentation": {}
    },
    {
        "label": "hackRemoveDuplicateStyleEntries",
        "importPath": "patch_apk.utils.remove_duplicate_style",
        "description": "patch_apk.utils.remove_duplicate_style",
        "isExtraImport": true,
        "detail": "patch_apk.utils.remove_duplicate_style",
        "documentation": {}
    },
    {
        "label": "hackRemoveDuplicateStyleEntries",
        "importPath": "patch_apk.utils.remove_duplicate_style",
        "description": "patch_apk.utils.remove_duplicate_style",
        "isExtraImport": true,
        "detail": "patch_apk.utils.remove_duplicate_style",
        "documentation": {}
    },
    {
        "label": "fixPublicResourceIDs",
        "importPath": "patch_apk.utils.fix_resource_id",
        "description": "patch_apk.utils.fix_resource_id",
        "isExtraImport": true,
        "detail": "patch_apk.utils.fix_resource_id",
        "documentation": {}
    },
    {
        "label": "fixPublicResourceIDs",
        "importPath": "patch_apk.utils.fix_resource_id",
        "description": "patch_apk.utils.fix_resource_id",
        "isExtraImport": true,
        "detail": "patch_apk.utils.fix_resource_id",
        "documentation": {}
    },
    {
        "label": "detectProGuard",
        "importPath": "patch_apk.utils.apk_detect_proguard",
        "description": "patch_apk.utils.apk_detect_proguard",
        "isExtraImport": true,
        "detail": "patch_apk.utils.apk_detect_proguard",
        "documentation": {}
    },
    {
        "label": "detectProGuard",
        "importPath": "patch_apk.utils.apk_detect_proguard",
        "description": "patch_apk.utils.apk_detect_proguard",
        "isExtraImport": true,
        "detail": "patch_apk.utils.apk_detect_proguard",
        "documentation": {}
    },
    {
        "label": "copySplitApkFiles",
        "importPath": "patch_apk.utils.copy_split_apks",
        "description": "patch_apk.utils.copy_split_apks",
        "isExtraImport": true,
        "detail": "patch_apk.utils.copy_split_apks",
        "documentation": {}
    },
    {
        "label": "copySplitApkFiles",
        "importPath": "patch_apk.utils.copy_split_apks",
        "description": "patch_apk.utils.copy_split_apks",
        "isExtraImport": true,
        "detail": "patch_apk.utils.copy_split_apks",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "colored",
        "importPath": "termcolor",
        "description": "termcolor",
        "isExtraImport": true,
        "detail": "termcolor",
        "documentation": {}
    },
    {
        "label": "colored",
        "importPath": "termcolor",
        "description": "termcolor",
        "isExtraImport": true,
        "detail": "termcolor",
        "documentation": {}
    },
    {
        "label": "colored",
        "importPath": "termcolor",
        "description": "termcolor",
        "isExtraImport": true,
        "detail": "termcolor",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "NULL_DECODED_DRAWABLE_COLOR",
        "importPath": "patch_apk.config.constants",
        "description": "patch_apk.config.constants",
        "isExtraImport": true,
        "detail": "patch_apk.config.constants",
        "documentation": {}
    },
    {
        "label": "NULL_DECODED_DRAWABLE_COLOR",
        "importPath": "patch_apk.config.constants",
        "description": "patch_apk.config.constants",
        "isExtraImport": true,
        "detail": "patch_apk.config.constants",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "APKTool",
        "importPath": "patch_apk.core.apk_tool",
        "description": "patch_apk.core.apk_tool",
        "isExtraImport": true,
        "detail": "patch_apk.core.apk_tool",
        "documentation": {}
    },
    {
        "label": "APKTool",
        "importPath": "patch_apk.core.apk_tool",
        "description": "patch_apk.core.apk_tool",
        "isExtraImport": true,
        "detail": "patch_apk.core.apk_tool",
        "documentation": {}
    },
    {
        "label": "APKTool",
        "importPath": "patch_apk.core.apk_tool",
        "description": "patch_apk.core.apk_tool",
        "isExtraImport": true,
        "detail": "patch_apk.core.apk_tool",
        "documentation": {}
    },
    {
        "label": "APKTool",
        "importPath": "patch_apk.core.apk_tool",
        "description": "patch_apk.core.apk_tool",
        "isExtraImport": true,
        "detail": "patch_apk.core.apk_tool",
        "documentation": {}
    },
    {
        "label": "APKTool",
        "importPath": "patch_apk.core.apk_tool",
        "description": "patch_apk.core.apk_tool",
        "isExtraImport": true,
        "detail": "patch_apk.core.apk_tool",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "APKTool",
        "importPath": "core.apk_tool",
        "description": "core.apk_tool",
        "isExtraImport": true,
        "detail": "core.apk_tool",
        "documentation": {}
    },
    {
        "label": "checkDependencies",
        "importPath": "patch_apk.utils.dependencies",
        "description": "patch_apk.utils.dependencies",
        "isExtraImport": true,
        "detail": "patch_apk.utils.dependencies",
        "documentation": {}
    },
    {
        "label": "checkDependencies",
        "importPath": "patch_apk.utils.dependencies",
        "description": "patch_apk.utils.dependencies",
        "isExtraImport": true,
        "detail": "patch_apk.utils.dependencies",
        "documentation": {}
    },
    {
        "label": "fixAPKBeforeObjection",
        "importPath": "patch_apk.utils.frida_objection",
        "description": "patch_apk.utils.frida_objection",
        "isExtraImport": true,
        "detail": "patch_apk.utils.frida_objection",
        "documentation": {}
    },
    {
        "label": "fixAPKBeforeObjection",
        "importPath": "patch_apk.utils.frida_objection",
        "description": "patch_apk.utils.frida_objection",
        "isExtraImport": true,
        "detail": "patch_apk.utils.frida_objection",
        "documentation": {}
    },
    {
        "label": "patchingWithObjection",
        "importPath": "patch_apk.utils.frida_objection",
        "description": "patch_apk.utils.frida_objection",
        "isExtraImport": true,
        "detail": "patch_apk.utils.frida_objection",
        "documentation": {}
    },
    {
        "label": "getTargetAPK",
        "importPath": "patch_apk.utils.get_target_apk",
        "description": "patch_apk.utils.get_target_apk",
        "isExtraImport": true,
        "detail": "patch_apk.utils.get_target_apk",
        "documentation": {}
    },
    {
        "label": "getTargetAPK",
        "importPath": "patch_apk.utils.get_target_apk",
        "description": "patch_apk.utils.get_target_apk",
        "isExtraImport": true,
        "detail": "patch_apk.utils.get_target_apk",
        "documentation": {}
    },
    {
        "label": "getAPKPathsForPackage",
        "importPath": "patch_apk.utils.get_apk_paths",
        "description": "patch_apk.utils.get_apk_paths",
        "isExtraImport": true,
        "detail": "patch_apk.utils.get_apk_paths",
        "documentation": {}
    },
    {
        "label": "getAPKPathsForPackage",
        "importPath": "patch_apk.utils.get_apk_paths",
        "description": "patch_apk.utils.get_apk_paths",
        "isExtraImport": true,
        "detail": "patch_apk.utils.get_apk_paths",
        "documentation": {}
    },
    {
        "label": "verifyPackageName",
        "importPath": "patch_apk.utils.verify_package_name",
        "description": "patch_apk.utils.verify_package_name",
        "isExtraImport": true,
        "detail": "patch_apk.utils.verify_package_name",
        "documentation": {}
    },
    {
        "label": "verifyPackageName",
        "importPath": "patch_apk.utils.verify_package_name",
        "description": "patch_apk.utils.verify_package_name",
        "isExtraImport": true,
        "detail": "patch_apk.utils.verify_package_name",
        "documentation": {}
    },
    {
        "label": "patch_apk.utils.remove_duplicate_class",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "patch_apk.utils.remove_duplicate_class",
        "description": "patch_apk.utils.remove_duplicate_class",
        "detail": "patch_apk.utils.remove_duplicate_class",
        "documentation": {}
    },
    {
        "label": "remove_duplicate_classes",
        "importPath": "patch_apk.utils.remove_duplicate_class",
        "description": "patch_apk.utils.remove_duplicate_class",
        "isExtraImport": true,
        "detail": "patch_apk.utils.remove_duplicate_class",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "NULL_DECODED_DRAWABLE_COLOR",
        "kind": 5,
        "importPath": "build.lib.patch_apk.config.constants",
        "description": "build.lib.patch_apk.config.constants",
        "peekOfCode": "NULL_DECODED_DRAWABLE_COLOR = \"#000000ff\"",
        "detail": "build.lib.patch_apk.config.constants",
        "documentation": {}
    },
    {
        "label": "APKBuilder",
        "kind": 6,
        "importPath": "build.lib.patch_apk.core.apk_builder",
        "description": "build.lib.patch_apk.core.apk_builder",
        "peekOfCode": "class APKBuilder:\n    \"\"\"Handles APK building and rebuilding operations.\"\"\"\n    @staticmethod\n    def build(baseapkdir):\n        # Fix private resources preventing builds (apktool wontfix: https://github.com/iBotPeaches/Apktool/issues/2761)\n        fixPrivateResources(baseapkdir)\n        verbosePrint(\"[+] Rebuilding APK with apktool.\")\n        result = APKTool.runApkTool([\"b\", baseapkdir])\n        if result[\"returncode\"] != 0:\n            abort(\"Error: Failed to run 'apktool b \" + baseapkdir + \"'.\\nRun with --debug-output for more information.\")",
        "detail": "build.lib.patch_apk.core.apk_builder",
        "documentation": {}
    },
    {
        "label": "APKTool",
        "kind": 6,
        "importPath": "build.lib.patch_apk.core.apk_tool",
        "description": "build.lib.patch_apk.core.apk_tool",
        "peekOfCode": "class APKTool:\n    '''\n    ApkTool class for handling APK files.\n    This class provides a way to interface with apktool, a powerful tool for\n    decompiling and recompiling Android APK files. It also provides helper\n    functions for common operations when working with APK files.\n    Attributes:\n        None\n    Methods:\n        runApkTool(params): Run apktool with the given parameters.",
        "detail": "build.lib.patch_apk.core.apk_tool",
        "documentation": {}
    },
    {
        "label": "detectProGuard",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.apk_detect_proguard",
        "description": "build.lib.patch_apk.utils.apk_detect_proguard",
        "peekOfCode": "def detectProGuard(extractedPath):\n    if os.path.exists(os.path.join(extractedPath, \"original\", \"META-INF\", \"proguard\")):\n        return True\n    if os.path.exists(os.path.join(extractedPath, \"original\", \"META-INF\", \"MANIFEST.MF\")):\n        fh = open(os.path.join(extractedPath, \"original\", \"META-INF\", \"MANIFEST.MF\"))\n        d = fh.read()\n        fh.close()\n        if \"proguard\" in d.lower():\n            return True\n    return False",
        "detail": "build.lib.patch_apk.utils.apk_detect_proguard",
        "documentation": {}
    },
    {
        "label": "getArgs",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.cli_tools",
        "description": "build.lib.patch_apk.utils.cli_tools",
        "peekOfCode": "def getArgs():\n    # Only parse args once\n    if not hasattr(getArgs, \"parsed_args\"):\n        # Parse the command line\n        parser = argparse.ArgumentParser(\n            description=\"patch-apk - Pull and patch Android apps for use with objection/frida. Supports split APKs.\"\n        )\n        parser.add_argument(\"--no-enable-user-certs\", help=\"Prevent patch-apk from enabling user-installed certificate support via network security config in the patched APK.\", action=\"store_true\")\n        parser.add_argument(\"--save-apk\", help=\"Save a copy of the APK (or single APK) prior to patching for use with other tools. APK will be saved under the given name.\")\n        parser.add_argument(\"--extract-only\", help=\"Disable including objection and pushing modified APK to device.\", action=\"store_true\")",
        "detail": "build.lib.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.cli_tools",
        "description": "build.lib.patch_apk.utils.cli_tools",
        "peekOfCode": "def abort(msg):\n    print(colored(msg, \"red\"))\n    sys.exit(1)\ndef verbosePrint(msg):\n    if getArgs().verbose:\n        for line in msg.split(\"\\n\"):\n            print(colored(\"    \" + line, \"light_grey\"))\ndef dbgPrint(msg):\n    if getArgs().debug_output:\n        print(msg)",
        "detail": "build.lib.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.cli_tools",
        "description": "build.lib.patch_apk.utils.cli_tools",
        "peekOfCode": "def verbosePrint(msg):\n    if getArgs().verbose:\n        for line in msg.split(\"\\n\"):\n            print(colored(\"    \" + line, \"light_grey\"))\ndef dbgPrint(msg):\n    if getArgs().debug_output:\n        print(msg)\n####################\n# Warning print\n####################",
        "detail": "build.lib.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.cli_tools",
        "description": "build.lib.patch_apk.utils.cli_tools",
        "peekOfCode": "def dbgPrint(msg):\n    if getArgs().debug_output:\n        print(msg)\n####################\n# Warning print\n####################\ndef warningPrint(msg):\n    print(colored(msg, \"yellow\"))\ndef getStdout():\n    if getArgs().debug_output:",
        "detail": "build.lib.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.cli_tools",
        "description": "build.lib.patch_apk.utils.cli_tools",
        "peekOfCode": "def warningPrint(msg):\n    print(colored(msg, \"yellow\"))\ndef getStdout():\n    if getArgs().debug_output:\n        return None\n    else:\n        return subprocess.DEVNULL\ndef assertSubprocessSuccessfulRun(args):\n    if subprocess.run(args, stdout=getStdout(), stderr=getStdout()).returncode != 0:\n        abort(f\"Error: Failed to run {' '.join(args)}.\\nRun with --debug-output for more information.\")",
        "detail": "build.lib.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "getStdout",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.cli_tools",
        "description": "build.lib.patch_apk.utils.cli_tools",
        "peekOfCode": "def getStdout():\n    if getArgs().debug_output:\n        return None\n    else:\n        return subprocess.DEVNULL\ndef assertSubprocessSuccessfulRun(args):\n    if subprocess.run(args, stdout=getStdout(), stderr=getStdout()).returncode != 0:\n        abort(f\"Error: Failed to run {' '.join(args)}.\\nRun with --debug-output for more information.\")",
        "detail": "build.lib.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.cli_tools",
        "description": "build.lib.patch_apk.utils.cli_tools",
        "peekOfCode": "def assertSubprocessSuccessfulRun(args):\n    if subprocess.run(args, stdout=getStdout(), stderr=getStdout()).returncode != 0:\n        abort(f\"Error: Failed to run {' '.join(args)}.\\nRun with --debug-output for more information.\")",
        "detail": "build.lib.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "copySplitApkFiles",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.copy_split_apks",
        "description": "build.lib.patch_apk.utils.copy_split_apks",
        "peekOfCode": "def copySplitApkFiles(baseapkdir, splitapkpaths):\n    for apkdir in splitapkpaths:\n        for (root, dirs, files) in os.walk(apkdir):\n            # Skip the original files directory\n            if not root.startswith(os.path.join(apkdir, \"original\")):\n                # Create any missing directories\n                for d in dirs:\n                    # Translate directory path to base APK path and create the directory if it doesn't exist\n                    p = baseapkdir + os.path.join(root, d)[len(apkdir):]\n                    if not os.path.exists(p):",
        "detail": "build.lib.patch_apk.utils.copy_split_apks",
        "documentation": {}
    },
    {
        "label": "checkDependencies",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.dependencies",
        "description": "build.lib.patch_apk.utils.dependencies",
        "peekOfCode": "def checkDependencies(extract_only):\n    deps = [\"adb\", \"apktool\", \"aapt\"]\n    if not extract_only:\n        deps += [\"objection\", \"zipalign\", \"apksigner\"]\n    missing = []\n    for dep in deps:\n        if shutil.which(dep) is None:\n            missing.append(dep)\n    if len(missing) > 0:\n        abort(\"Error, missing dependencies, ensure the following commands are available on the PATH: \" + (\", \".join(missing)))",
        "detail": "build.lib.patch_apk.utils.dependencies",
        "documentation": {}
    },
    {
        "label": "disableApkSplitting",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.disable_apk_split",
        "description": "build.lib.patch_apk.utils.disable_apk_split",
        "peekOfCode": "def disableApkSplitting(baseapkdir):\n    verbosePrint(\"[+] Disabling APK splitting in AndroidManifest.xml of base APK.\")\n    # Load AndroidManifest.xml\n    tree = xml.etree.ElementTree.parse(os.path.join(baseapkdir, \"AndroidManifest.xml\"))\n    # Register the namespaces and get the prefix for the \"android\" namespace\n    namespaces = dict([node for _,node in xml.etree.ElementTree.iterparse(os.path.join(baseapkdir, \"AndroidManifest.xml\"), events=[\"start-ns\"])]) # pyright: ignore[reportArgumentType]\n    for ns in namespaces:\n        xml.etree.ElementTree.register_namespace(ns, namespaces[ns])\n    ns = \"{\" + namespaces[\"android\"] + \"}\"\n    # Disable APK splitting",
        "detail": "build.lib.patch_apk.utils.disable_apk_split",
        "documentation": {}
    },
    {
        "label": "fixPrivateResources",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.fix_private_resources",
        "description": "build.lib.patch_apk.utils.fix_private_resources",
        "peekOfCode": "def fixPrivateResources(baseapkdir):\n    verbosePrint(\"[+] Forcing all private resources to be public\")\n    updated = 0\n    for (root, dirs, files) in os.walk(os.path.join(baseapkdir, \"res\")):\n        for f in files:\n            if f.lower().endswith(\".xml\"):\n                rawREReplace(os.path.join(root, f), '@android', '@*android')\n                updated += 1\n    if updated > 0:\n        verbosePrint(\"[+] Updated \" + str(updated) + \" private resources before building APK.\")",
        "detail": "build.lib.patch_apk.utils.fix_private_resources",
        "documentation": {}
    },
    {
        "label": "fixPublicResourceIDs",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.fix_resource_id",
        "description": "build.lib.patch_apk.utils.fix_resource_id",
        "peekOfCode": "def fixPublicResourceIDs(baseapkdir, splitapkpaths):\n    # Bail if the base APK does not have a public.xml\n    if not os.path.exists(os.path.join(baseapkdir, \"res\", \"values\", \"public.xml\")):\n        return\n    verbosePrint(\"[+] Found public.xml in the base APK, fixing resource identifiers across split APKs.\")\n    # Mappings of resource IDs and names\n    idToDummyName = {}\n    dummyNameToRealName = {}\n    # Step 1) Find all resource IDs that apktool has assigned a name of APKTOOL_DUMMY_XXX to.\n    #         Load these into the lookup tables ready to resolve the real resource names from",
        "detail": "build.lib.patch_apk.utils.fix_resource_id",
        "documentation": {}
    },
    {
        "label": "fixAPKBeforeObjection",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.frida_objection",
        "description": "build.lib.patch_apk.utils.frida_objection",
        "peekOfCode": "def fixAPKBeforeObjection(apkfile, fix_network_security_config):\n    print(\"[+] Prepping AndroidManifest.xml\")\n    with tempfile.TemporaryDirectory() as tmppath:\n        apkdir = os.path.join(tmppath, \"apk\")\n        ret = APKTool.runApkTool([\"d\", apkfile, \"-o\", apkdir])\n        if ret[\"returncode\"] != 0:\n            abort(\"Error: Failed to run 'apktool d \" + apkfile + \" -o \" + apkdir + \"'.\\nRun with --debug-output for more information.\")\n        # Load AndroidManifest.xml\n        manifestPath = os.path.join(apkdir, \"AndroidManifest.xml\")\n        tree = xml.etree.ElementTree.parse(manifestPath)",
        "detail": "build.lib.patch_apk.utils.frida_objection",
        "documentation": {}
    },
    {
        "label": "getAPKPathsForPackage",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.get_apk_paths",
        "description": "build.lib.patch_apk.utils.get_apk_paths",
        "peekOfCode": "def getAPKPathsForPackage(pkgname, current_user = \"0\", users_to_try = None):\n    print(f\"[+] Retrieving APK path(s) for package: {pkgname} for user {current_user}\")\n    paths = []\n    proc = subprocess.run([\"adb\", \"shell\", \"pm\", \"path\", \"--user\", current_user, pkgname], stdout=subprocess.PIPE)\n    if proc.returncode != 0:\n        if not users_to_try:\n            proc = subprocess.run([\"adb\", \"shell\", \"pm\", \"list\", \"users\"], stdout=subprocess.PIPE)\n            out = proc.stdout.decode(\"utf-8\")\n            pattern = r'UserInfo{(\\d+):'\n            users_to_try = re.findall(pattern, out)",
        "detail": "build.lib.patch_apk.utils.get_apk_paths",
        "documentation": {}
    },
    {
        "label": "getTargetAPK",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.get_target_apk",
        "description": "build.lib.patch_apk.utils.get_target_apk",
        "peekOfCode": "def getTargetAPK(pkgname, apkpaths, tmppath, disableStylesHack, extract_only):\n    # Pull the APKs from the device\n    bar = Bar('[+] Pulling APK file(s) from device', max=len(apkpaths))\n    verboseOutput = \"\"\n    localapks = []\n    for remotepath in apkpaths:\n        baseapkname = remotepath.split('/')[-1]\n        localapks.append(os.path.join(tmppath, pkgname + \"-\" + baseapkname))\n        verboseOutput += f\"[+] Pulled: {pkgname}-{baseapkname}\"\n        bar.next()",
        "detail": "build.lib.patch_apk.utils.get_target_apk",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.raw_re_replace",
        "description": "build.lib.patch_apk.utils.raw_re_replace",
        "peekOfCode": "def rawREReplace(path, pattern, replacement):\n    if os.path.exists(path):\n        contents = \"\"\n        with open(path, 'r') as file:\n            contents = file.read()\n        newContents = re.sub(pattern, replacement, contents)\n        if (contents != newContents):\n            dbgPrint(\"[~] Patching \" + path)\n            with open(path, 'w') as file:\n                file.write(newContents)",
        "detail": "build.lib.patch_apk.utils.raw_re_replace",
        "documentation": {}
    },
    {
        "label": "hackRemoveDuplicateStyleEntries",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.remove_duplicate_style",
        "description": "build.lib.patch_apk.utils.remove_duplicate_style",
        "peekOfCode": "def hackRemoveDuplicateStyleEntries(baseapkdir):\n    # Bail if there is no styles.xml\n    if not os.path.exists(os.path.join(baseapkdir, \"res\", \"values\", \"styles.xml\")):\n        return",
        "detail": "build.lib.patch_apk.utils.remove_duplicate_style",
        "documentation": {}
    },
    {
        "label": "verifyPackageName",
        "kind": 2,
        "importPath": "build.lib.patch_apk.utils.verify_package_name",
        "description": "build.lib.patch_apk.utils.verify_package_name",
        "peekOfCode": "def verifyPackageName(pkgname):\n    # Get a list of installed packages matching the given name\n    packages = []\n    proc = subprocess.run([\"adb\", \"shell\", \"pm\", \"list\", \"packages\"], stdout=subprocess.PIPE)\n    if proc.returncode != 0:\n        abort(\"Error: Failed to run 'adb shell pm list packages'.\")\n    out = proc.stdout.decode(\"utf-8\")\n    for line in out.split(os.linesep):\n        if line.startswith(\"package:\"):\n            line = line[8:].strip()",
        "detail": "build.lib.patch_apk.utils.verify_package_name",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "build.lib.patch_apk.main",
        "description": "build.lib.patch_apk.main",
        "peekOfCode": "def main():\n    # Grab argz\n    args = getArgs()\n    # Check that dependencies are available\n    checkDependencies(args.extract_only)\n    # Warn for unexpected version\n    apktoolVersion = APKTool.getApktoolVersion()\n    print(f\"Using apktool v{apktoolVersion}\")\n    # Verify the package name and ensure it's installed (also supports partial package names)\n    pkgname = verifyPackageName(args.pkgname)",
        "detail": "build.lib.patch_apk.main",
        "documentation": {}
    },
    {
        "label": "NULL_DECODED_DRAWABLE_COLOR",
        "kind": 5,
        "importPath": "src.patch_apk.config.constants",
        "description": "src.patch_apk.config.constants",
        "peekOfCode": "NULL_DECODED_DRAWABLE_COLOR = \"#000000ff\"",
        "detail": "src.patch_apk.config.constants",
        "documentation": {}
    },
    {
        "label": "APKBuilder",
        "kind": 6,
        "importPath": "src.patch_apk.core.apk_builder",
        "description": "src.patch_apk.core.apk_builder",
        "peekOfCode": "class APKBuilder:\n    \"\"\"Handles APK building and rebuilding operations.\"\"\"\n    @staticmethod\n    def build(baseapkdir):\n        # Fix private resources preventing builds (apktool wontfix: https://github.com/iBotPeaches/Apktool/issues/2761)\n        fixPrivateResources(baseapkdir)\n        verbosePrint(\"[+] Rebuilding APK with apktool.\")\n        result = APKTool.runApkTool([\"b\", baseapkdir])\n        if result[\"returncode\"] != 0:\n            abort(\"Error: Failed to run 'apktool b \" + baseapkdir + \"'.\\nRun with --debug-output for more information.\")",
        "detail": "src.patch_apk.core.apk_builder",
        "documentation": {}
    },
    {
        "label": "APKTool",
        "kind": 6,
        "importPath": "src.patch_apk.core.apk_tool",
        "description": "src.patch_apk.core.apk_tool",
        "peekOfCode": "class APKTool:\n    '''\n    ApkTool class for handling APK files.\n    This class provides a way to interface with apktool, a powerful tool for\n    decompiling and recompiling Android APK files. It also provides helper\n    functions for common operations when working with APK files.\n    Attributes:\n        None\n    Methods:\n        runApkTool(params): Run apktool with the given parameters.",
        "detail": "src.patch_apk.core.apk_tool",
        "documentation": {}
    },
    {
        "label": "detectProGuard",
        "kind": 2,
        "importPath": "src.patch_apk.utils.apk_detect_proguard",
        "description": "src.patch_apk.utils.apk_detect_proguard",
        "peekOfCode": "def detectProGuard(extractedPath):\n    if os.path.exists(os.path.join(extractedPath, \"original\", \"META-INF\", \"proguard\")):\n        return True\n    if os.path.exists(os.path.join(extractedPath, \"original\", \"META-INF\", \"MANIFEST.MF\")):\n        fh = open(os.path.join(extractedPath, \"original\", \"META-INF\", \"MANIFEST.MF\"))\n        d = fh.read()\n        fh.close()\n        if \"proguard\" in d.lower():\n            return True\n    return False",
        "detail": "src.patch_apk.utils.apk_detect_proguard",
        "documentation": {}
    },
    {
        "label": "getArgs",
        "kind": 2,
        "importPath": "src.patch_apk.utils.cli_tools",
        "description": "src.patch_apk.utils.cli_tools",
        "peekOfCode": "def getArgs():\n    # Only parse args once\n    if not hasattr(getArgs, \"parsed_args\"):\n        # Parse the command line\n        parser = argparse.ArgumentParser(\n            description=\"patch-apk - Pull and patch Android apps for use with objection/frida. Supports split APKs.\"\n        )\n        parser.add_argument(\"--no-enable-user-certs\", help=\"Prevent patch-apk from enabling user-installed certificate support via network security config in the patched APK.\", action=\"store_true\")\n        parser.add_argument(\"--save-apk\", help=\"Save a copy of the APK (or single APK) prior to patching for use with other tools. APK will be saved under the given name.\")\n        parser.add_argument(\"--extract-only\", help=\"Disable including objection and pushing modified APK to device.\", action=\"store_true\")",
        "detail": "src.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "kind": 2,
        "importPath": "src.patch_apk.utils.cli_tools",
        "description": "src.patch_apk.utils.cli_tools",
        "peekOfCode": "def abort(msg):\n    print(colored(msg, \"red\"))\n    sys.exit(1)\ndef verbosePrint(msg):\n    if getArgs().verbose:\n        for line in msg.split(\"\\n\"):\n            print(colored(\"    \" + line, \"light_grey\"))\ndef dbgPrint(msg):\n    if getArgs().debug_output:\n        print(msg)",
        "detail": "src.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "kind": 2,
        "importPath": "src.patch_apk.utils.cli_tools",
        "description": "src.patch_apk.utils.cli_tools",
        "peekOfCode": "def verbosePrint(msg):\n    if getArgs().verbose:\n        for line in msg.split(\"\\n\"):\n            print(colored(\"    \" + line, \"light_grey\"))\ndef dbgPrint(msg):\n    if getArgs().debug_output:\n        print(msg)\n####################\n# Warning print\n####################",
        "detail": "src.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "kind": 2,
        "importPath": "src.patch_apk.utils.cli_tools",
        "description": "src.patch_apk.utils.cli_tools",
        "peekOfCode": "def dbgPrint(msg):\n    if getArgs().debug_output:\n        print(msg)\n####################\n# Warning print\n####################\ndef warningPrint(msg):\n    print(colored(msg, \"yellow\"))\ndef getStdout():\n    if getArgs().debug_output:",
        "detail": "src.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "kind": 2,
        "importPath": "src.patch_apk.utils.cli_tools",
        "description": "src.patch_apk.utils.cli_tools",
        "peekOfCode": "def warningPrint(msg):\n    print(colored(msg, \"yellow\"))\ndef getStdout():\n    if getArgs().debug_output:\n        return None\n    else:\n        return subprocess.DEVNULL\ndef assertSubprocessSuccessfulRun(args):\n    if subprocess.run(args, stdout=getStdout(), stderr=getStdout()).returncode != 0:\n        abort(f\"Error: Failed to run {' '.join(args)}.\\nRun with --debug-output for more information.\")",
        "detail": "src.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "getStdout",
        "kind": 2,
        "importPath": "src.patch_apk.utils.cli_tools",
        "description": "src.patch_apk.utils.cli_tools",
        "peekOfCode": "def getStdout():\n    if getArgs().debug_output:\n        return None\n    else:\n        return subprocess.DEVNULL\ndef assertSubprocessSuccessfulRun(args):\n    if subprocess.run(args, stdout=getStdout(), stderr=getStdout()).returncode != 0:\n        abort(f\"Error: Failed to run {' '.join(args)}.\\nRun with --debug-output for more information.\")",
        "detail": "src.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "kind": 2,
        "importPath": "src.patch_apk.utils.cli_tools",
        "description": "src.patch_apk.utils.cli_tools",
        "peekOfCode": "def assertSubprocessSuccessfulRun(args):\n    if subprocess.run(args, stdout=getStdout(), stderr=getStdout()).returncode != 0:\n        abort(f\"Error: Failed to run {' '.join(args)}.\\nRun with --debug-output for more information.\")",
        "detail": "src.patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "copySplitApkFiles",
        "kind": 2,
        "importPath": "src.patch_apk.utils.copy_split_apks",
        "description": "src.patch_apk.utils.copy_split_apks",
        "peekOfCode": "def copySplitApkFiles(baseapkdir, splitapkpaths):\n    for apkdir in splitapkpaths:\n        for (root, dirs, files) in os.walk(apkdir):\n            # Skip the original files directory\n            if not root.startswith(os.path.join(apkdir, \"original\")):\n                # Create any missing directories\n                for d in dirs:\n                    # Translate directory path to base APK path and create the directory if it doesn't exist\n                    p = baseapkdir + os.path.join(root, d)[len(apkdir):]\n                    if not os.path.exists(p):",
        "detail": "src.patch_apk.utils.copy_split_apks",
        "documentation": {}
    },
    {
        "label": "checkDependencies",
        "kind": 2,
        "importPath": "src.patch_apk.utils.dependencies",
        "description": "src.patch_apk.utils.dependencies",
        "peekOfCode": "def checkDependencies(extract_only):\n    deps = [\"adb\", \"apktool\", \"aapt\"]\n    if not extract_only:\n        deps += [\"objection\", \"zipalign\", \"apksigner\"]\n    missing = []\n    for dep in deps:\n        if shutil.which(dep) is None:\n            missing.append(dep)\n    if len(missing) > 0:\n        abort(\"Error, missing dependencies, ensure the following commands are available on the PATH: \" + (\", \".join(missing)))",
        "detail": "src.patch_apk.utils.dependencies",
        "documentation": {}
    },
    {
        "label": "disableApkSplitting",
        "kind": 2,
        "importPath": "src.patch_apk.utils.disable_apk_split",
        "description": "src.patch_apk.utils.disable_apk_split",
        "peekOfCode": "def disableApkSplitting(baseapkdir):\n    verbosePrint(\"[+] Disabling APK splitting in AndroidManifest.xml of base APK.\")\n    # Load AndroidManifest.xml\n    tree = xml.etree.ElementTree.parse(os.path.join(baseapkdir, \"AndroidManifest.xml\"))\n    # Register the namespaces and get the prefix for the \"android\" namespace\n    namespaces = dict([node for _,node in xml.etree.ElementTree.iterparse(os.path.join(baseapkdir, \"AndroidManifest.xml\"), events=[\"start-ns\"])]) # pyright: ignore[reportArgumentType]\n    for ns in namespaces:\n        xml.etree.ElementTree.register_namespace(ns, namespaces[ns])\n    ns = \"{\" + namespaces[\"android\"] + \"}\"\n    # Disable APK splitting",
        "detail": "src.patch_apk.utils.disable_apk_split",
        "documentation": {}
    },
    {
        "label": "fixPrivateResources",
        "kind": 2,
        "importPath": "src.patch_apk.utils.fix_private_resources",
        "description": "src.patch_apk.utils.fix_private_resources",
        "peekOfCode": "def fixPrivateResources(baseapkdir):\n    verbosePrint(\"[+] Forcing all private resources to be public\")\n    updated = 0\n    for (root, dirs, files) in os.walk(os.path.join(baseapkdir, \"res\")):\n        for f in files:\n            if f.lower().endswith(\".xml\"):\n                rawREReplace(os.path.join(root, f), '@android', '@*android')\n                updated += 1\n    if updated > 0:\n        verbosePrint(\"[+] Updated \" + str(updated) + \" private resources before building APK.\")",
        "detail": "src.patch_apk.utils.fix_private_resources",
        "documentation": {}
    },
    {
        "label": "fixPublicResourceIDs",
        "kind": 2,
        "importPath": "src.patch_apk.utils.fix_resource_id",
        "description": "src.patch_apk.utils.fix_resource_id",
        "peekOfCode": "def fixPublicResourceIDs(baseapkdir, splitapkpaths):\n    # Bail if the base APK does not have a public.xml\n    if not os.path.exists(os.path.join(baseapkdir, \"res\", \"values\", \"public.xml\")):\n        return\n    verbosePrint(\"[+] Found public.xml in the base APK, fixing resource identifiers across split APKs.\")\n    # Mappings of resource IDs and names\n    idToDummyName = {}\n    dummyNameToRealName = {}\n    # Step 1) Find all resource IDs that apktool has assigned a name of APKTOOL_DUMMY_XXX to.\n    #         Load these into the lookup tables ready to resolve the real resource names from",
        "detail": "src.patch_apk.utils.fix_resource_id",
        "documentation": {}
    },
    {
        "label": "fixAPKBeforeObjection",
        "kind": 2,
        "importPath": "src.patch_apk.utils.frida_objection",
        "description": "src.patch_apk.utils.frida_objection",
        "peekOfCode": "def fixAPKBeforeObjection(apkfile, fix_network_security_config):\n    print(\"[+] Prepping AndroidManifest.xml\")\n    with tempfile.TemporaryDirectory() as tmppath:\n        apkdir = os.path.join(tmppath, \"apk\")\n        ret = APKTool.runApkTool([\"d\", \"--only-main-classes\", apkfile, \"-o\", apkdir,])\n        if ret[\"returncode\"] != 0:\n            abort(\"Error: Failed to run 'apktool d \" + apkfile + \" -o \" + apkdir + \"'.\\nRun with --debug-output for more information.\")\n        # Load AndroidManifest.xml\n        manifestPath = os.path.join(apkdir, \"AndroidManifest.xml\")\n        tree = xml.etree.ElementTree.parse(manifestPath)",
        "detail": "src.patch_apk.utils.frida_objection",
        "documentation": {}
    },
    {
        "label": "patchingWithObjection",
        "kind": 2,
        "importPath": "src.patch_apk.utils.frida_objection",
        "description": "src.patch_apk.utils.frida_objection",
        "peekOfCode": "def patchingWithObjection(apkfile):\n        # Patch the target APK with objection\n    print(\"[+] Patching \" + apkfile.split(os.sep)[-1] + \" with objection.\")\n    warningPrint(\"[!] The application will be patched with Frida 16.7.19. See https://github.com/sensepost/objection/issues/737 for more information.\")\n    if subprocess.run([\"objection\", \"patchapk\", \"-V\", \"16.7.19\", \"--skip-resources\", \"--ignore-nativelibs\", \"-s\", apkfile], capture_output=True).returncode != 0:\n        print(\"[+] Objection patching failed, trying alternative approach\")\n        warningPrint(\"[!] If you get an error, the application might not have a launchable activity\")\n        # Try without --skip-resources, since objection potentially wasn't able to identify the starting activity\n        # There could have been another reason for the failure, but it's a sensible fallback\n        # Another reason could be a missing INTERNET permission",
        "detail": "src.patch_apk.utils.frida_objection",
        "documentation": {}
    },
    {
        "label": "getAPKPathsForPackage",
        "kind": 2,
        "importPath": "src.patch_apk.utils.get_apk_paths",
        "description": "src.patch_apk.utils.get_apk_paths",
        "peekOfCode": "def getAPKPathsForPackage(pkgname, current_user = \"0\", users_to_try = None):\n    print(f\"[+] Retrieving APK path(s) for package: {pkgname} for user {current_user}\")\n    paths = []\n    proc = subprocess.run([\"adb\", \"shell\", \"pm\", \"path\", \"--user\", current_user, pkgname], stdout=subprocess.PIPE)\n    if proc.returncode != 0:\n        if not users_to_try:\n            proc = subprocess.run([\"adb\", \"shell\", \"pm\", \"list\", \"users\"], stdout=subprocess.PIPE)\n            out = proc.stdout.decode(\"utf-8\")\n            pattern = r'UserInfo{(\\d+):'\n            users_to_try = re.findall(pattern, out)",
        "detail": "src.patch_apk.utils.get_apk_paths",
        "documentation": {}
    },
    {
        "label": "getTargetAPK",
        "kind": 2,
        "importPath": "src.patch_apk.utils.get_target_apk",
        "description": "src.patch_apk.utils.get_target_apk",
        "peekOfCode": "def getTargetAPK(pkgname, apkpaths, tmppath, disableStylesHack, extract_only):\n    # Pull the APKs from the device\n    bar = Bar('[+] Pulling APK file(s) from device', max=len(apkpaths))\n    verboseOutput = \"\"\n    localapks = []\n    for remotepath in apkpaths:\n        baseapkname = remotepath.split('/')[-1]\n        localapks.append(os.path.join(tmppath, pkgname + \"-\" + baseapkname))\n        verboseOutput += f\"[+] Pulled: {pkgname}-{baseapkname}\"\n        bar.next()",
        "detail": "src.patch_apk.utils.get_target_apk",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "kind": 2,
        "importPath": "src.patch_apk.utils.raw_re_replace",
        "description": "src.patch_apk.utils.raw_re_replace",
        "peekOfCode": "def rawREReplace(path, pattern, replacement):\n    if os.path.exists(path):\n        contents = \"\"\n        with open(path, 'r') as file:\n            contents = file.read()\n        newContents = re.sub(pattern, replacement, contents)\n        if (contents != newContents):\n            dbgPrint(\"[~] Patching \" + path)\n            with open(path, 'w') as file:\n                file.write(newContents)",
        "detail": "src.patch_apk.utils.raw_re_replace",
        "documentation": {}
    },
    {
        "label": "remove_duplicate_classes",
        "kind": 2,
        "importPath": "src.patch_apk.utils.remove_duplicate_class",
        "description": "src.patch_apk.utils.remove_duplicate_class",
        "peekOfCode": "def remove_duplicate_classes(apkdir):\n    \"\"\"\n    Remove duplicate/conflicting smali classes from smali_assets directory.\n    This prevents 'has already been interned' errors during APK rebuild.\n    \"\"\"\n    smali_assets = os.path.join(apkdir, \"smali_assets\")\n    if not os.path.exists(smali_assets):\n        print(\"[+] No smali_assets directory found, skipping duplicate check\")\n        return\n    print(\"[+] Scanning for conflicting smali classes...\")",
        "detail": "src.patch_apk.utils.remove_duplicate_class",
        "documentation": {}
    },
    {
        "label": "hackRemoveDuplicateStyleEntries",
        "kind": 2,
        "importPath": "src.patch_apk.utils.remove_duplicate_style",
        "description": "src.patch_apk.utils.remove_duplicate_style",
        "peekOfCode": "def hackRemoveDuplicateStyleEntries(baseapkdir):\n    # Bail if there is no styles.xml\n    if not os.path.exists(os.path.join(baseapkdir, \"res\", \"values\", \"styles.xml\")):\n        return",
        "detail": "src.patch_apk.utils.remove_duplicate_style",
        "documentation": {}
    },
    {
        "label": "verifyPackageName",
        "kind": 2,
        "importPath": "src.patch_apk.utils.verify_package_name",
        "description": "src.patch_apk.utils.verify_package_name",
        "peekOfCode": "def verifyPackageName(pkgname):\n    # Get a list of installed packages matching the given name\n    packages = []\n    proc = subprocess.run([\"adb\", \"shell\", \"pm\", \"list\", \"packages\"], stdout=subprocess.PIPE)\n    if proc.returncode != 0:\n        abort(\"Error: Failed to run 'adb shell pm list packages'.\")\n    out = proc.stdout.decode(\"utf-8\")\n    for line in out.split(os.linesep):\n        if line.startswith(\"package:\"):\n            line = line[8:].strip()",
        "detail": "src.patch_apk.utils.verify_package_name",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.patch_apk.main",
        "description": "src.patch_apk.main",
        "peekOfCode": "def main():\n    # Grab argz\n    args = getArgs()\n    # Check that dependencies are available\n    checkDependencies(args.extract_only)\n    # Warn for unexpected version\n    apktoolVersion = APKTool.getApktoolVersion()\n    print(f\"Using apktool v{apktoolVersion}\")\n    # Verify the package name and ensure it's installed (also supports partial package names)\n    pkgname = verifyPackageName(args.pkgname)",
        "detail": "src.patch_apk.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def main():\n    # Grab argz\n    args = getArgs()\n    # Check that dependencies are available\n    checkDependencies(args.extract_only)\n    # Warn for unexpected version\n    apktoolVersion = getApktoolVersion()\n    print(f\"Using apktool v{apktoolVersion}\")\n    # Verify the package name and ensure it's installed (also supports partial package names)\n    pkgname = verifyPackageName(args.pkgname)",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def assertSubprocessSuccessfulRun(args):\n    if subprocess.run(args, stdout=getStdout(), stderr=getStdout()).returncode != 0:\n        abort(f\"Error: Failed to run {' '.join(args)}.\\nRun with --debug-output for more information.\")\ndef fixAPKBeforeObjection(apkfile, fix_network_security_config):\n    print(\"[+] Prepping AndroidManifest.xml\")\n    with tempfile.TemporaryDirectory() as tmppath:\n        apkdir = os.path.join(tmppath, \"apk\")\n        ret = runApkTool([\"d\", apkfile, \"-o\", apkdir])\n        if ret[\"returncode\"] != 0:\n            abort(\"Error: Failed to run 'apktool d \" + apkfile + \" -o \" + apkdir + \"'.\\nRun with --debug-output for more information.\")",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "fixAPKBeforeObjection",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def fixAPKBeforeObjection(apkfile, fix_network_security_config):\n    print(\"[+] Prepping AndroidManifest.xml\")\n    with tempfile.TemporaryDirectory() as tmppath:\n        apkdir = os.path.join(tmppath, \"apk\")\n        ret = runApkTool([\"d\", apkfile, \"-o\", apkdir])\n        if ret[\"returncode\"] != 0:\n            abort(\"Error: Failed to run 'apktool d \" + apkfile + \" -o \" + apkdir + \"'.\\nRun with --debug-output for more information.\")\n        # Load AndroidManifest.xml\n        manifestPath = os.path.join(apkdir, \"AndroidManifest.xml\")\n        tree = xml.etree.ElementTree.parse(manifestPath)",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "checkDependencies",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def checkDependencies(extract_only):\n    deps = [\"adb\", \"apktool\", \"aapt\"]\n    if not extract_only:\n        deps += [\"objection\", \"zipalign\", \"apksigner\"]\n    missing = []\n    for dep in deps:\n        if shutil.which(dep) is None:\n            missing.append(dep)\n    if len(missing) > 0:\n        abort(\"Error, missing dependencies, ensure the following commands are available on the PATH: \" + (\", \".join(missing)))",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "getArgs",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def getArgs():\n    # Only parse args once\n    if not hasattr(getArgs, \"parsed_args\"):\n        # Parse the command line\n        parser = argparse.ArgumentParser(\n            description=\"patch-apk - Pull and patch Android apps for use with objection/frida. Supports split APKs.\"\n        )\n        parser.add_argument(\"--no-enable-user-certs\", help=\"Prevent patch-apk from enabling user-installed certificate support via network security config in the patched APK.\", action=\"store_true\")\n        parser.add_argument(\"--save-apk\", help=\"Save a copy of the APK (or single APK) prior to patching for use with other tools. APK will be saved under the given name.\")\n        parser.add_argument(\"--extract-only\", help=\"Disable including objection and pushing modified APK to device.\", action=\"store_true\")",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def dbgPrint(msg):\n    if getArgs().debug_output:\n        print(msg)\n####################\n# Warning print\n####################\ndef warningPrint(msg):\n    print(colored(msg, \"yellow\"))\n####################\n# Abort will print given error message and exit the app",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def warningPrint(msg):\n    print(colored(msg, \"yellow\"))\n####################\n# Abort will print given error message and exit the app\n####################\ndef abort(msg):\n    print(colored(msg, \"red\"))\n    sys.exit(1)\n####################\n# Get the stdout target for subprocess calls. Set to DEVNULL unless debug output is enabled.",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "abort",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def abort(msg):\n    print(colored(msg, \"red\"))\n    sys.exit(1)\n####################\n# Get the stdout target for subprocess calls. Set to DEVNULL unless debug output is enabled.\n####################\ndef getStdout():\n    if getArgs().debug_output:\n        return None\n    else:",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "getStdout",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def getStdout():\n    if getArgs().debug_output:\n        return None\n    else:\n        return subprocess.DEVNULL\n####################\n# Get apktool version\n####################\ndef getApktoolVersion():\n    commands = [[\"version\"], [\"v\"], [\"-version\"], [\"-v\"]]    ",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "getApktoolVersion",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def getApktoolVersion():\n    commands = [[\"version\"], [\"v\"], [\"-version\"], [\"-v\"]]    \n    for cmd in commands:\n        try:\n            result = runApkTool(cmd)\n            if result[\"returncode\"] != 0:\n                continue\n            version_output = result[\"stdout\"].strip().split(\"\\n\")[0].strip()\n            version_str = version_output.split(\"-\")[0].strip()\n            return parse_version(version_str)",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "runApkTool",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def runApkTool(params):\n    exe = \"apktool.bat\" if os.name == \"nt\" else \"apktool\"\n    # Feed \"\\r\\n\" so apktool.bat's `pause` won’t block on Windows.\n    cp = subprocess.run(\n        [exe, *params],\n        input=\"\\r\\n\",        # Should be harmless on linux\n        text=True,\n        capture_output=True,\n        check=False,\n    )",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "fixPrivateResources",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def fixPrivateResources(baseapkdir):\n    verbosePrint(\"[+] Forcing all private resources to be public\")\n    updated = 0\n    for (root, dirs, files) in os.walk(os.path.join(baseapkdir, \"res\")):\n        for f in files:\n            if f.lower().endswith(\".xml\"):\n                rawREReplace(os.path.join(root, f), '@android', '@*android')\n                updated += 1\n    if updated > 0:\n        verbosePrint(\"[+] Updated \" + str(updated) + \" private resources before building APK.\")",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "build",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def build(baseapkdir):\n    # Fix private resources preventing builds (apktool wontfix: https://github.com/iBotPeaches/Apktool/issues/2761)\n    fixPrivateResources(baseapkdir)\n    verbosePrint(\"[+] Rebuilding APK with apktool.\")\n    result = runApkTool([\"b\", baseapkdir])\n    if result[\"returncode\"] != 0:\n        abort(\"Error: Failed to run 'apktool b \" + baseapkdir + \"'.\\nRun with --debug-output for more information.\")\n####################\n# Sign the APK with apksigner and zip align\n# Fixes https://github.com/NickstaDB/patch-apk/issues/31 by no longer using jarsigner (V1 APK signatures)",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "signAndZipAlign",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def signAndZipAlign(baseapkdir, baseapkfilename):\n    # Zip align the new APK\n    verbosePrint(\"[+] Zip aligning new APK.\")\n    assertSubprocessSuccessfulRun([\"zipalign\", \"-f\", \"4\", \"-p\", os.path.join(baseapkdir, \"dist\", baseapkfilename),\n        os.path.join(baseapkdir, \"dist\", baseapkfilename[:-4] + \"-aligned.apk\")])\n    shutil.move(os.path.join(baseapkdir, \"dist\", baseapkfilename[:-4] + \"-aligned.apk\"), os.path.join(baseapkdir, \"dist\", baseapkfilename))\n    # Sign the new APK\n    verbosePrint(\"[+] Signing new APK.\")\n    apkpath = os.path.join(baseapkdir, \"dist\", baseapkfilename)\n    assertSubprocessSuccessfulRun([\"objection\", \"signapk\", apkpath])",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "verifyPackageName",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def verifyPackageName(pkgname):\n    # Get a list of installed packages matching the given name\n    packages = []\n    proc = subprocess.run([\"adb\", \"shell\", \"pm\", \"list\", \"packages\"], stdout=subprocess.PIPE)\n    if proc.returncode != 0:\n        abort(\"Error: Failed to run 'adb shell pm list packages'.\")\n    out = proc.stdout.decode(\"utf-8\")\n    for line in out.split(os.linesep):\n        if line.startswith(\"package:\"):\n            line = line[8:].strip()",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "getAPKPathsForPackage",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def getAPKPathsForPackage(pkgname, current_user = \"0\", users_to_try = None):\n    print(f\"[+] Retrieving APK path(s) for package: {pkgname} for user {current_user}\")\n    paths = []\n    proc = subprocess.run([\"adb\", \"shell\", \"pm\", \"path\", \"--user\", current_user, pkgname], stdout=subprocess.PIPE)\n    if proc.returncode != 0:\n        if not users_to_try:\n            proc = subprocess.run([\"adb\", \"shell\", \"pm\", \"list\", \"users\"], stdout=subprocess.PIPE)\n            out = proc.stdout.decode(\"utf-8\")\n            pattern = r'UserInfo{(\\d+):'\n            users_to_try = re.findall(pattern, out)",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "getTargetAPK",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def getTargetAPK(pkgname, apkpaths, tmppath, disableStylesHack, extract_only):\n    # Pull the APKs from the device\n    bar = Bar('[+] Pulling APK file(s) from device', max=len(apkpaths))\n    verboseOutput = \"\"\n    localapks = []\n    for remotepath in apkpaths:\n        baseapkname = remotepath.split('/')[-1]\n        localapks.append(os.path.join(tmppath, pkgname + \"-\" + baseapkname))\n        verboseOutput += f\"[+] Pulled: {pkgname}-{baseapkname}\"\n        bar.next()",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def verbosePrint(msg):\n    if getArgs().verbose:\n        for line in msg.split(\"\\n\"):\n            print(colored(\"    \" + line, \"light_grey\"))\n####################\n# Combine app bundles/split APKs into a single APK for patching.\n####################\ndef combineSplitAPKs(pkgname, localapks, tmppath, disableStylesHack, extract_only):\n    warningPrint(\"[!] App bundle/split APK detected, rebuilding as a single APK.\")\n    # Extract the individual APKs",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "combineSplitAPKs",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def combineSplitAPKs(pkgname, localapks, tmppath, disableStylesHack, extract_only):\n    warningPrint(\"[!] App bundle/split APK detected, rebuilding as a single APK.\")\n    # Extract the individual APKs\n    baseapkdir = os.path.join(tmppath, pkgname + \"-base\")\n    baseapkfilename = pkgname + \"-base.apk\"\n    splitapkpaths = []\n    bar = Bar('[+] Disassembling split APKs', max=len(localapks))\n    verboseOutput = \"\"\n    for apkpath in localapks:\n        verboseOutput += \"\\nExtracted: \" + apkpath",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "detectProGuard",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def detectProGuard(extractedPath):\n    if os.path.exists(os.path.join(extractedPath, \"original\", \"META-INF\", \"proguard\")):\n        return True\n    if os.path.exists(os.path.join(extractedPath, \"original\", \"META-INF\", \"MANIFEST.MF\")):\n        fh = open(os.path.join(extractedPath, \"original\", \"META-INF\", \"MANIFEST.MF\"))\n        d = fh.read()\n        fh.close()\n        if \"proguard\" in d.lower():\n            return True\n    return False",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "copySplitApkFiles",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def copySplitApkFiles(baseapkdir, splitapkpaths):\n    for apkdir in splitapkpaths:\n        for (root, dirs, files) in os.walk(apkdir):\n            # Skip the original files directory\n            if not root.startswith(os.path.join(apkdir, \"original\")):\n                # Create any missing directories\n                for d in dirs:\n                    # Translate directory path to base APK path and create the directory if it doesn't exist\n                    p = baseapkdir + os.path.join(root, d)[len(apkdir):]\n                    if not os.path.exists(p):",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "fixPublicResourceIDs",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def fixPublicResourceIDs(baseapkdir, splitapkpaths):\n    # Bail if the base APK does not have a public.xml\n    if not os.path.exists(os.path.join(baseapkdir, \"res\", \"values\", \"public.xml\")):\n        return\n    verbosePrint(\"[+] Found public.xml in the base APK, fixing resource identifiers across split APKs.\")\n    # Mappings of resource IDs and names\n    idToDummyName = {}\n    dummyNameToRealName = {}\n    # Step 1) Find all resource IDs that apktool has assigned a name of APKTOOL_DUMMY_XXX to.\n    #         Load these into the lookup tables ready to resolve the real resource names from",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "hackRemoveDuplicateStyleEntries",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def hackRemoveDuplicateStyleEntries(baseapkdir):\n    # Bail if there is no styles.xml\n    if not os.path.exists(os.path.join(baseapkdir, \"res\", \"values\", \"styles.xml\")):\n        return\n    # Duplicates\n    dupes = []\n    # Parse styles.xml and find all <item> elements with duplicate names\n    tree = xml.etree.ElementTree.parse(os.path.join(baseapkdir, \"res\", \"values\", \"styles.xml\"))\n    for styleEl in tree.getroot().findall(\"style\"):\n        itemNames = []",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "disableApkSplitting",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def disableApkSplitting(baseapkdir):\n    verbosePrint(\"[+] Disabling APK splitting in AndroidManifest.xml of base APK.\")\n    # Load AndroidManifest.xml\n    tree = xml.etree.ElementTree.parse(os.path.join(baseapkdir, \"AndroidManifest.xml\"))\n    # Register the namespaces and get the prefix for the \"android\" namespace\n    namespaces = dict([node for _,node in xml.etree.ElementTree.iterparse(os.path.join(baseapkdir, \"AndroidManifest.xml\"), events=[\"start-ns\"])])\n    for ns in namespaces:\n        xml.etree.ElementTree.register_namespace(ns, namespaces[ns])\n    ns = \"{\" + namespaces[\"android\"] + \"}\"\n    # Disable APK splitting",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "kind": 2,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "def rawREReplace(path, pattern, replacement):\n    if os.path.exists(path):\n        contents = \"\"\n        with open(path, 'r') as file:\n            contents = file.read()\n        newContents = re.sub(pattern, replacement, contents)\n        if (contents != newContents):\n            dbgPrint(\"[~] Patching \" + path)\n            with open(path, 'w') as file:\n                file.write(newContents)",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "NULL_DECODED_DRAWABLE_COLOR",
        "kind": 5,
        "importPath": "patch-apk",
        "description": "patch-apk",
        "peekOfCode": "NULL_DECODED_DRAWABLE_COLOR = \"#000000ff\"\n####################\n# Main()\n####################\ndef main():\n    # Grab argz\n    args = getArgs()\n    # Check that dependencies are available\n    checkDependencies(args.extract_only)\n    # Warn for unexpected version",
        "detail": "patch-apk",
        "documentation": {}
    },
    {
        "label": "read_requirements",
        "kind": 2,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "def read_requirements(req_file: Path):\n    if not req_file.exists():\n        return []\n    lines = req_file.read_text(encoding=\"utf-8\").splitlines()\n    reqs = [l.strip() for l in lines if l.strip() and not l.strip().startswith(\"#\")]\n    return reqs\ndef get_version(pkg_init: Path):\n    if not pkg_init.exists():\n        return \"0.0.0\"\n    text = pkg_init.read_text(encoding=\"utf-8\")",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "get_version",
        "kind": 2,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "def get_version(pkg_init: Path):\n    if not pkg_init.exists():\n        return \"0.0.0\"\n    text = pkg_init.read_text(encoding=\"utf-8\")\n    m = re.search(r\"__version__\\s*=\\s*['\\\"]([^'\\\"]+)['\\\"]\", text)\n    return m.group(1) if m else \"0.0.0\"\nlong_description = \"\"\nreadme_file = HERE / \"README.md\"\nif readme_file.exists():\n    long_description = readme_file.read_text(encoding=\"utf-8\")",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "HERE",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "HERE = Path(__file__).parent\ndef read_requirements(req_file: Path):\n    if not req_file.exists():\n        return []\n    lines = req_file.read_text(encoding=\"utf-8\").splitlines()\n    reqs = [l.strip() for l in lines if l.strip() and not l.strip().startswith(\"#\")]\n    return reqs\ndef get_version(pkg_init: Path):\n    if not pkg_init.exists():\n        return \"0.0.0\"",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "long_description",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "long_description = \"\"\nreadme_file = HERE / \"README.md\"\nif readme_file.exists():\n    long_description = readme_file.read_text(encoding=\"utf-8\")\ninstall_requires = read_requirements(HERE / \"requirements.txt\")\nsetup(\n    name=\"patch-apk\",\n    version=get_version(HERE / \"src\" / \"patch_apk\" / \"__init__.py\"),\n    description=\"App Bundle / Split APK aware patcher for objection\",\n    long_description=long_description,",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "readme_file",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "readme_file = HERE / \"README.md\"\nif readme_file.exists():\n    long_description = readme_file.read_text(encoding=\"utf-8\")\ninstall_requires = read_requirements(HERE / \"requirements.txt\")\nsetup(\n    name=\"patch-apk\",\n    version=get_version(HERE / \"src\" / \"patch_apk\" / \"__init__.py\"),\n    description=\"App Bundle / Split APK aware patcher for objection\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "install_requires",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "install_requires = read_requirements(HERE / \"requirements.txt\")\nsetup(\n    name=\"patch-apk\",\n    version=get_version(HERE / \"src\" / \"patch_apk\" / \"__init__.py\"),\n    description=\"App Bundle / Split APK aware patcher for objection\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    include_package_data=True,",
        "detail": "setup",
        "documentation": {}
    }
]