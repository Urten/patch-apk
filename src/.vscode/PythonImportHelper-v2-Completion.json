[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "getStdout",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "getArgs",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "isExtraImport": true,
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "fixPrivateResources",
        "importPath": "patch_apk.utils.fix_private_resources",
        "description": "patch_apk.utils.fix_private_resources",
        "isExtraImport": true,
        "detail": "patch_apk.utils.fix_private_resources",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Bar",
        "importPath": "progress.bar",
        "description": "progress.bar",
        "isExtraImport": true,
        "detail": "progress.bar",
        "documentation": {}
    },
    {
        "label": "Bar",
        "importPath": "progress.bar",
        "description": "progress.bar",
        "isExtraImport": true,
        "detail": "progress.bar",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "packaging.version",
        "description": "packaging.version",
        "isExtraImport": true,
        "detail": "packaging.version",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "importPath": "patch_apk.utils.raw_re_replace",
        "description": "patch_apk.utils.raw_re_replace",
        "isExtraImport": true,
        "detail": "patch_apk.utils.raw_re_replace",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "importPath": "patch_apk.utils.raw_re_replace",
        "description": "patch_apk.utils.raw_re_replace",
        "isExtraImport": true,
        "detail": "patch_apk.utils.raw_re_replace",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "importPath": "patch_apk.utils.raw_re_replace",
        "description": "patch_apk.utils.raw_re_replace",
        "isExtraImport": true,
        "detail": "patch_apk.utils.raw_re_replace",
        "documentation": {}
    },
    {
        "label": "disableApkSplitting",
        "importPath": "patch_apk.utils.disable_apk_split",
        "description": "patch_apk.utils.disable_apk_split",
        "isExtraImport": true,
        "detail": "patch_apk.utils.disable_apk_split",
        "documentation": {}
    },
    {
        "label": "hackRemoveDuplicateStyleEntries",
        "importPath": "patch_apk.utils.remove_duplicate_style",
        "description": "patch_apk.utils.remove_duplicate_style",
        "isExtraImport": true,
        "detail": "patch_apk.utils.remove_duplicate_style",
        "documentation": {}
    },
    {
        "label": "fixPublicResourceIDs",
        "importPath": "patch_apk.utils.fix_resource_id",
        "description": "patch_apk.utils.fix_resource_id",
        "isExtraImport": true,
        "detail": "patch_apk.utils.fix_resource_id",
        "documentation": {}
    },
    {
        "label": "detectProGuard",
        "importPath": "patch_apk.utils.apk_detect_proguard",
        "description": "patch_apk.utils.apk_detect_proguard",
        "isExtraImport": true,
        "detail": "patch_apk.utils.apk_detect_proguard",
        "documentation": {}
    },
    {
        "label": "copySplitApkFiles",
        "importPath": "patch_apk.utils.copy_split_apks",
        "description": "patch_apk.utils.copy_split_apks",
        "isExtraImport": true,
        "detail": "patch_apk.utils.copy_split_apks",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "colored",
        "importPath": "termcolor",
        "description": "termcolor",
        "isExtraImport": true,
        "detail": "termcolor",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "NULL_DECODED_DRAWABLE_COLOR",
        "importPath": "patch_apk.config.constants",
        "description": "patch_apk.config.constants",
        "isExtraImport": true,
        "detail": "patch_apk.config.constants",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "APKTool",
        "importPath": "patch_apk.core.apk_tool",
        "description": "patch_apk.core.apk_tool",
        "isExtraImport": true,
        "detail": "patch_apk.core.apk_tool",
        "documentation": {}
    },
    {
        "label": "APKTool",
        "importPath": "patch_apk.core.apk_tool",
        "description": "patch_apk.core.apk_tool",
        "isExtraImport": true,
        "detail": "patch_apk.core.apk_tool",
        "documentation": {}
    },
    {
        "label": "APKTool",
        "importPath": "patch_apk.core.apk_tool",
        "description": "patch_apk.core.apk_tool",
        "isExtraImport": true,
        "detail": "patch_apk.core.apk_tool",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "checkDependencies",
        "importPath": "patch_apk.utils.dependencies",
        "description": "patch_apk.utils.dependencies",
        "isExtraImport": true,
        "detail": "patch_apk.utils.dependencies",
        "documentation": {}
    },
    {
        "label": "fixAPKBeforeObjection",
        "importPath": "patch_apk.utils.frida_objection",
        "description": "patch_apk.utils.frida_objection",
        "isExtraImport": true,
        "detail": "patch_apk.utils.frida_objection",
        "documentation": {}
    },
    {
        "label": "getTargetAPK",
        "importPath": "patch_apk.utils.get_target_apk",
        "description": "patch_apk.utils.get_target_apk",
        "isExtraImport": true,
        "detail": "patch_apk.utils.get_target_apk",
        "documentation": {}
    },
    {
        "label": "getAPKPathsForPackage",
        "importPath": "patch_apk.utils.get_apk_paths",
        "description": "patch_apk.utils.get_apk_paths",
        "isExtraImport": true,
        "detail": "patch_apk.utils.get_apk_paths",
        "documentation": {}
    },
    {
        "label": "verifyPackageName",
        "importPath": "patch_apk.utils.verify_package_name",
        "description": "patch_apk.utils.verify_package_name",
        "isExtraImport": true,
        "detail": "patch_apk.utils.verify_package_name",
        "documentation": {}
    },
    {
        "label": "NULL_DECODED_DRAWABLE_COLOR",
        "kind": 5,
        "importPath": "patch_apk.config.constants",
        "description": "patch_apk.config.constants",
        "peekOfCode": "NULL_DECODED_DRAWABLE_COLOR = \"#000000ff\"",
        "detail": "patch_apk.config.constants",
        "documentation": {}
    },
    {
        "label": "APKBuilder",
        "kind": 6,
        "importPath": "patch_apk.core.apk_builder",
        "description": "patch_apk.core.apk_builder",
        "peekOfCode": "class APKBuilder:\n    \"\"\"Handles APK building and rebuilding operations.\"\"\"\n    @staticmethod\n    def build(baseapkdir):\n        # Fix private resources preventing builds (apktool wontfix: https://github.com/iBotPeaches/Apktool/issues/2761)\n        fixPrivateResources(baseapkdir)\n        verbosePrint(\"[+] Rebuilding APK with apktool.\")\n        result = APKTool.runApkTool([\"b\", baseapkdir])\n        if result[\"returncode\"] != 0:\n            abort(\"Error: Failed to run 'apktool b \" + baseapkdir + \"'.\\nRun with --debug-output for more information.\")",
        "detail": "patch_apk.core.apk_builder",
        "documentation": {}
    },
    {
        "label": "APKTool",
        "kind": 6,
        "importPath": "patch_apk.core.apk_tool",
        "description": "patch_apk.core.apk_tool",
        "peekOfCode": "class APKTool:\n    '''\n    ApkTool class for handling APK files.\n    This class provides a way to interface with apktool, a powerful tool for\n    decompiling and recompiling Android APK files. It also provides helper\n    functions for common operations when working with APK files.\n    Attributes:\n        None\n    Methods:\n        runApkTool(params): Run apktool with the given parameters.",
        "detail": "patch_apk.core.apk_tool",
        "documentation": {}
    },
    {
        "label": "detectProGuard",
        "kind": 2,
        "importPath": "patch_apk.utils.apk_detect_proguard",
        "description": "patch_apk.utils.apk_detect_proguard",
        "peekOfCode": "def detectProGuard(extractedPath):\n    if os.path.exists(os.path.join(extractedPath, \"original\", \"META-INF\", \"proguard\")):\n        return True\n    if os.path.exists(os.path.join(extractedPath, \"original\", \"META-INF\", \"MANIFEST.MF\")):\n        fh = open(os.path.join(extractedPath, \"original\", \"META-INF\", \"MANIFEST.MF\"))\n        d = fh.read()\n        fh.close()\n        if \"proguard\" in d.lower():\n            return True\n    return False",
        "detail": "patch_apk.utils.apk_detect_proguard",
        "documentation": {}
    },
    {
        "label": "getArgs",
        "kind": 2,
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "peekOfCode": "def getArgs():\n    # Only parse args once\n    if not hasattr(getArgs, \"parsed_args\"):\n        # Parse the command line\n        parser = argparse.ArgumentParser(\n            description=\"patch-apk - Pull and patch Android apps for use with objection/frida. Supports split APKs.\"\n        )\n        parser.add_argument(\"--no-enable-user-certs\", help=\"Prevent patch-apk from enabling user-installed certificate support via network security config in the patched APK.\", action=\"store_true\")\n        parser.add_argument(\"--save-apk\", help=\"Save a copy of the APK (or single APK) prior to patching for use with other tools. APK will be saved under the given name.\")\n        parser.add_argument(\"--extract-only\", help=\"Disable including objection and pushing modified APK to device.\", action=\"store_true\")",
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "abort",
        "kind": 2,
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "peekOfCode": "def abort(msg):\n    print(colored(msg, \"red\"))\n    sys.exit(1)\ndef verbosePrint(msg):\n    if getArgs().verbose:\n        for line in msg.split(\"\\n\"):\n            print(colored(\"    \" + line, \"light_grey\"))\ndef dbgPrint(msg):\n    if getArgs().debug_output:\n        print(msg)",
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "verbosePrint",
        "kind": 2,
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "peekOfCode": "def verbosePrint(msg):\n    if getArgs().verbose:\n        for line in msg.split(\"\\n\"):\n            print(colored(\"    \" + line, \"light_grey\"))\ndef dbgPrint(msg):\n    if getArgs().debug_output:\n        print(msg)\n####################\n# Warning print\n####################",
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "dbgPrint",
        "kind": 2,
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "peekOfCode": "def dbgPrint(msg):\n    if getArgs().debug_output:\n        print(msg)\n####################\n# Warning print\n####################\ndef warningPrint(msg):\n    print(colored(msg, \"yellow\"))\ndef getStdout():\n    if getArgs().debug_output:",
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "warningPrint",
        "kind": 2,
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "peekOfCode": "def warningPrint(msg):\n    print(colored(msg, \"yellow\"))\ndef getStdout():\n    if getArgs().debug_output:\n        return None\n    else:\n        return subprocess.DEVNULL\ndef assertSubprocessSuccessfulRun(args):\n    if subprocess.run(args, stdout=getStdout(), stderr=getStdout()).returncode != 0:\n        abort(f\"Error: Failed to run {' '.join(args)}.\\nRun with --debug-output for more information.\")",
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "getStdout",
        "kind": 2,
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "peekOfCode": "def getStdout():\n    if getArgs().debug_output:\n        return None\n    else:\n        return subprocess.DEVNULL\ndef assertSubprocessSuccessfulRun(args):\n    if subprocess.run(args, stdout=getStdout(), stderr=getStdout()).returncode != 0:\n        abort(f\"Error: Failed to run {' '.join(args)}.\\nRun with --debug-output for more information.\")",
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "assertSubprocessSuccessfulRun",
        "kind": 2,
        "importPath": "patch_apk.utils.cli_tools",
        "description": "patch_apk.utils.cli_tools",
        "peekOfCode": "def assertSubprocessSuccessfulRun(args):\n    if subprocess.run(args, stdout=getStdout(), stderr=getStdout()).returncode != 0:\n        abort(f\"Error: Failed to run {' '.join(args)}.\\nRun with --debug-output for more information.\")",
        "detail": "patch_apk.utils.cli_tools",
        "documentation": {}
    },
    {
        "label": "copySplitApkFiles",
        "kind": 2,
        "importPath": "patch_apk.utils.copy_split_apks",
        "description": "patch_apk.utils.copy_split_apks",
        "peekOfCode": "def copySplitApkFiles(baseapkdir, splitapkpaths):\n    for apkdir in splitapkpaths:\n        for (root, dirs, files) in os.walk(apkdir):\n            # Skip the original files directory\n            if not root.startswith(os.path.join(apkdir, \"original\")):\n                # Create any missing directories\n                for d in dirs:\n                    # Translate directory path to base APK path and create the directory if it doesn't exist\n                    p = baseapkdir + os.path.join(root, d)[len(apkdir):]\n                    if not os.path.exists(p):",
        "detail": "patch_apk.utils.copy_split_apks",
        "documentation": {}
    },
    {
        "label": "checkDependencies",
        "kind": 2,
        "importPath": "patch_apk.utils.dependencies",
        "description": "patch_apk.utils.dependencies",
        "peekOfCode": "def checkDependencies(extract_only):\n    deps = [\"adb\", \"apktool\", \"aapt\"]\n    if not extract_only:\n        deps += [\"objection\", \"zipalign\", \"apksigner\"]\n    missing = []\n    for dep in deps:\n        if shutil.which(dep) is None:\n            missing.append(dep)\n    if len(missing) > 0:\n        abort(\"Error, missing dependencies, ensure the following commands are available on the PATH: \" + (\", \".join(missing)))",
        "detail": "patch_apk.utils.dependencies",
        "documentation": {}
    },
    {
        "label": "disableApkSplitting",
        "kind": 2,
        "importPath": "patch_apk.utils.disable_apk_split",
        "description": "patch_apk.utils.disable_apk_split",
        "peekOfCode": "def disableApkSplitting(baseapkdir):\n    verbosePrint(\"[+] Disabling APK splitting in AndroidManifest.xml of base APK.\")\n    # Load AndroidManifest.xml\n    tree = xml.etree.ElementTree.parse(os.path.join(baseapkdir, \"AndroidManifest.xml\"))\n    # Register the namespaces and get the prefix for the \"android\" namespace\n    namespaces = dict([node for _,node in xml.etree.ElementTree.iterparse(os.path.join(baseapkdir, \"AndroidManifest.xml\"), events=[\"start-ns\"])]) # pyright: ignore[reportArgumentType]\n    for ns in namespaces:\n        xml.etree.ElementTree.register_namespace(ns, namespaces[ns])\n    ns = \"{\" + namespaces[\"android\"] + \"}\"\n    # Disable APK splitting",
        "detail": "patch_apk.utils.disable_apk_split",
        "documentation": {}
    },
    {
        "label": "fixPrivateResources",
        "kind": 2,
        "importPath": "patch_apk.utils.fix_private_resources",
        "description": "patch_apk.utils.fix_private_resources",
        "peekOfCode": "def fixPrivateResources(baseapkdir):\n    verbosePrint(\"[+] Forcing all private resources to be public\")\n    updated = 0\n    for (root, dirs, files) in os.walk(os.path.join(baseapkdir, \"res\")):\n        for f in files:\n            if f.lower().endswith(\".xml\"):\n                rawREReplace(os.path.join(root, f), '@android', '@*android')\n                updated += 1\n    if updated > 0:\n        verbosePrint(\"[+] Updated \" + str(updated) + \" private resources before building APK.\")",
        "detail": "patch_apk.utils.fix_private_resources",
        "documentation": {}
    },
    {
        "label": "fixPublicResourceIDs",
        "kind": 2,
        "importPath": "patch_apk.utils.fix_resource_id",
        "description": "patch_apk.utils.fix_resource_id",
        "peekOfCode": "def fixPublicResourceIDs(baseapkdir, splitapkpaths):\n    # Bail if the base APK does not have a public.xml\n    if not os.path.exists(os.path.join(baseapkdir, \"res\", \"values\", \"public.xml\")):\n        return\n    verbosePrint(\"[+] Found public.xml in the base APK, fixing resource identifiers across split APKs.\")\n    # Mappings of resource IDs and names\n    idToDummyName = {}\n    dummyNameToRealName = {}\n    # Step 1) Find all resource IDs that apktool has assigned a name of APKTOOL_DUMMY_XXX to.\n    #         Load these into the lookup tables ready to resolve the real resource names from",
        "detail": "patch_apk.utils.fix_resource_id",
        "documentation": {}
    },
    {
        "label": "fixAPKBeforeObjection",
        "kind": 2,
        "importPath": "patch_apk.utils.frida_objection",
        "description": "patch_apk.utils.frida_objection",
        "peekOfCode": "def fixAPKBeforeObjection(apkfile, fix_network_security_config):\n    print(\"[+] Prepping AndroidManifest.xml\")\n    with tempfile.TemporaryDirectory() as tmppath:\n        apkdir = os.path.join(tmppath, \"apk\")\n        ret = APKTool.runApkTool([\"d\", apkfile, \"-o\", apkdir])\n        if ret[\"returncode\"] != 0:\n            abort(\"Error: Failed to run 'apktool d \" + apkfile + \" -o \" + apkdir + \"'.\\nRun with --debug-output for more information.\")\n        # Load AndroidManifest.xml\n        manifestPath = os.path.join(apkdir, \"AndroidManifest.xml\")\n        tree = xml.etree.ElementTree.parse(manifestPath)",
        "detail": "patch_apk.utils.frida_objection",
        "documentation": {}
    },
    {
        "label": "getAPKPathsForPackage",
        "kind": 2,
        "importPath": "patch_apk.utils.get_apk_paths",
        "description": "patch_apk.utils.get_apk_paths",
        "peekOfCode": "def getAPKPathsForPackage(pkgname, current_user = \"0\", users_to_try = None):\n    print(f\"[+] Retrieving APK path(s) for package: {pkgname} for user {current_user}\")\n    paths = []\n    proc = subprocess.run([\"adb\", \"shell\", \"pm\", \"path\", \"--user\", current_user, pkgname], stdout=subprocess.PIPE)\n    if proc.returncode != 0:\n        if not users_to_try:\n            proc = subprocess.run([\"adb\", \"shell\", \"pm\", \"list\", \"users\"], stdout=subprocess.PIPE)\n            out = proc.stdout.decode(\"utf-8\")\n            pattern = r'UserInfo{(\\d+):'\n            users_to_try = re.findall(pattern, out)",
        "detail": "patch_apk.utils.get_apk_paths",
        "documentation": {}
    },
    {
        "label": "getTargetAPK",
        "kind": 2,
        "importPath": "patch_apk.utils.get_target_apk",
        "description": "patch_apk.utils.get_target_apk",
        "peekOfCode": "def getTargetAPK(pkgname, apkpaths, tmppath, disableStylesHack, extract_only):\n    # Pull the APKs from the device\n    bar = Bar('[+] Pulling APK file(s) from device', max=len(apkpaths))\n    verboseOutput = \"\"\n    localapks = []\n    for remotepath in apkpaths:\n        baseapkname = remotepath.split('/')[-1]\n        localapks.append(os.path.join(tmppath, pkgname + \"-\" + baseapkname))\n        verboseOutput += f\"[+] Pulled: {pkgname}-{baseapkname}\"\n        bar.next()",
        "detail": "patch_apk.utils.get_target_apk",
        "documentation": {}
    },
    {
        "label": "rawREReplace",
        "kind": 2,
        "importPath": "patch_apk.utils.raw_re_replace",
        "description": "patch_apk.utils.raw_re_replace",
        "peekOfCode": "def rawREReplace(path, pattern, replacement):\n    if os.path.exists(path):\n        contents = \"\"\n        with open(path, 'r') as file:\n            contents = file.read()\n        newContents = re.sub(pattern, replacement, contents)\n        if (contents != newContents):\n            dbgPrint(\"[~] Patching \" + path)\n            with open(path, 'w') as file:\n                file.write(newContents)",
        "detail": "patch_apk.utils.raw_re_replace",
        "documentation": {}
    },
    {
        "label": "hackRemoveDuplicateStyleEntries",
        "kind": 2,
        "importPath": "patch_apk.utils.remove_duplicate_style",
        "description": "patch_apk.utils.remove_duplicate_style",
        "peekOfCode": "def hackRemoveDuplicateStyleEntries(baseapkdir):\n    # Bail if there is no styles.xml\n    if not os.path.exists(os.path.join(baseapkdir, \"res\", \"values\", \"styles.xml\")):\n        return",
        "detail": "patch_apk.utils.remove_duplicate_style",
        "documentation": {}
    },
    {
        "label": "verifyPackageName",
        "kind": 2,
        "importPath": "patch_apk.utils.verify_package_name",
        "description": "patch_apk.utils.verify_package_name",
        "peekOfCode": "def verifyPackageName(pkgname):\n    # Get a list of installed packages matching the given name\n    packages = []\n    proc = subprocess.run([\"adb\", \"shell\", \"pm\", \"list\", \"packages\"], stdout=subprocess.PIPE)\n    if proc.returncode != 0:\n        abort(\"Error: Failed to run 'adb shell pm list packages'.\")\n    out = proc.stdout.decode(\"utf-8\")\n    for line in out.split(os.linesep):\n        if line.startswith(\"package:\"):\n            line = line[8:].strip()",
        "detail": "patch_apk.utils.verify_package_name",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "patch_apk.main",
        "description": "patch_apk.main",
        "peekOfCode": "def main():\n    # Grab argz\n    args = getArgs()\n    # Check that dependencies are available\n    checkDependencies(args.extract_only)\n    # Warn for unexpected version\n    apktoolVersion = APKTool.getApktoolVersion()\n    print(f\"Using apktool v{apktoolVersion}\")\n    # Verify the package name and ensure it's installed (also supports partial package names)\n    pkgname = verifyPackageName(args.pkgname)",
        "detail": "patch_apk.main",
        "documentation": {}
    }
]